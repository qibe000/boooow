#include <iostream>  
     using namespace std;
     int main()
    {
	        int j, i, k, n, m, t;
	        int a; 
	         scanf("%d", &t);
	        for (j = 1; j <= t; j++)
		         {
		             scanf("%d", &n);
		             int sum = 0, maxsum = -1001, first = 0, last = 0, temp = 1;
		             for (i = 0; i < n; i++)
			             {
			                 scanf("%d", &a);
			                 sum += a;
			                 if (sum > maxsum)
				                 {
				                     maxsum = sum; first = temp; last = i + 1;
				                 }
			                 if (sum < 0)
				                 {
				                     sum = 0; temp = i + 2;
				                }
			             }
			             printf("Case %d:\n%d %d %d\n", j, maxsum, first, last);
		             if (j != t)
			             {
			                 printf("\n");
			             }
		         }
	
		        return 0;
	     }
	 /*
	对于整个序列a[n]来说，它的所有子序列有很多很多，但是可以将它们归类。
注意，是以**结尾的子序列，其中肯定是要包含**的了
 
以a[0]结尾的子序列只有a[0]
以a[1]结尾的子序列有 a[0]a[1]和a[1]
以a[2]结尾的子序列有 a[0]a[1]a[2] / a[1]a[2] / a[2]
……
以a[i]结尾的子序列有a[0]a[1]……a[i-2]a[i-1]a[i]  / a[1]a[2]……a[i-2]a[i-1]a[i] /  a[2]a[3]……a[i-2]a[i-1]a[i] / …… /  a[i-1]a[i] / a[i]
 
所有以a[0] ~a[n]结尾的子序列分组构成了整个序列的所有子序列。
 
这样，我们只需求以a[0]~a[n]结尾的这些分组的子序列中的每一分组的最大子序列和。然后从n个分组最大子序列和中选出整个序列的最大子序列和。
 
观察可以发现，0，1，2，……，n结尾的分组中，
maxsum a[0] = a[0]
maxsum a[1] = max( a[0] + a[1] ，a[1])  = max( maxsum a[0] + a[1] ，a[1]) 
maxsum a[2] = max( max ( a[0] + a[1] + a[2]，a[1] + a[2] )，a[2])  
 = max(  max( a[0] + a[1] ，a[1]) + a[2] ， a[2]) 
 = max(  maxsum a[1] + a[2] ， a[2])
……
依此类推，可以得出通用的式子。
maxsum a[i] = max（ maxsum a[i-1] + a[i]，a[i])
 
 
用递归……当然，不递归也应该是可以解决的。
 
我们从maxsum  a[0]开始算起。
以后的每个就是  maxsum a[i-1] + a[i] 和 a[i] 中取大的那个。
 
程序中判断 前一个的最大子序列和小于零时，将其置为0，然后再加a[i] ，这样不就是和a[i] 一样大的么；前一个的最大子序列和只要大于零，那么再加上a[i] 肯定比 a[i] 要大，这样，带有归零的这个 maxsum a[i-1] + a[i] 就是以表示当前位置结束的子序列的最大和了。
 
 
剩下的就是要判断起始和终点位置了。
 
在循环的过程中，每循环一次就算出一个以当前位置结束的最大子序列和。每次循环中最大的那个保存下来，不就是最终所有最大子序列和中的最大值了么。
 
其中temp保存的是前一个位置的最大子序列和的开始位置（题目中是从1开始的哦）；当 sum > maxsum 时（程序中的条件，与说明时的maxsum不太一样哦）就记录最大值，并保持它的开始位置为temp，终止位置即为当前位置（i +1是因为题目中第一个为1，而不是0）；
 
当最大子序列和小于0时，将 temp = i + 2； 其中 i + 1 表示当前位置（理由如上），i + 2就表示当前位置的下一个位置了。既此最大子序列和为负值，那么下一个的最大子序列和应该是它本身，而不再累加前边的。
 
程序中就两个if 语句，想要说明白还真不容易。
 
还有，有人会问，当整个序列全是负数时，还对吗？负数也是成立的，如果全是负数的时候，它就是每次都只取当前值作为最大值了，因为负的跟负的不就越加越小了吗。
 
因为题目中给出的范围是-1000 ～1000，所以这里初始的maxsum 初始化为-1001 ，只有比所有可能的值都小时才行。maxsum初始化为0；那么当序列全是负数时，得出的最大值将是0……这就wrong了
 
 总之，只要上一个子序列最大和为正，那么无论当前值的正负，都会与当前的相加，这样以当前值结尾的子序列最大和就会增大。（一个正数 加一个 正数2 或者负数 那么都会比这个正数2 或负数原来要增大，同理，一个负数加任何一个数，都会使这个数减小，因此当前一子序列最大和小于零时，我们就归零它了，相当于是不加任何数，而保留当前位置值本身）
 
内存优化版：
理解了以上思想后，观察上一个代码我们发现，那个a[10000]基本上就没用啊，保存了一些输入数据，可是那些数据只用了一次就没用了。输入数据的for循环和处理数据的for循环是一模一样的，而且处理数据也只是用到当前输入的数据。
于是，数组也可以省去了，直接将两个循环合并。输入一个数据，直接累加……省下不少空间哦。
	 */